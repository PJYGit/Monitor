# 《基于实时视频分析的入侵监测系统》的**系统设计文档**

小组成员：董舜尧、郑栩僮、庞家耀、李高丞、马哲
指导老师：史华冬
时间：2019.7.9

---


[TOC]

---

## **1．引言**

### 1.1）编写目的

编写此系统设计文档以明确项目设计情况，明确人员分工与实现，并给出项目的基本设计流程和实现流程。

### 1.2）背景

基于实时的视频流,利用图像识别功能,自动检测视频中的运动物体。包括后端，数据处理和前端 web 页面实时显示结果, 同时支持异常图像上传至云服务器,有一定账户管理系统，可以配合手机 APP、微信推送，实现全方位,实时监控的目的。 

控制系统： Raspberry Pi3 

信息采集： Pi camera，支持红外功能 

语言和框架：Python、Java、Vue.js

### 1.3）参考资料

a. 华为云平台任务指导手册。 

b. U+新工科智慧云 

c. Vue.js文档 

d. OpenCV 文档

## **2．总体设计**

### 2.1）需求规定

a. 使用Raspberry Pi运行环境配置openCV 

b. 移动物体检测——高斯模糊功能 

c. 移动物体检测——背景移除功能 

d. 移动物体检测——物体标注功能 

e. 有图像分类、存储功能 

f. 心跳监测功能 

g. Web Socket服务端程序设计 

h. 账号管理功能 

i. 报警系统 

j. 直播系统

### 2.2）运行环境

#### 2.2.1）软件环境：

语言和框架：Python、OpenCV 、Java、Vue.js、PHP 

开发工具：PyCharm、Visual Stdio Code、IntelliJ IDEA

#### 2.2.2）硬件环境：

控制系统：Raspberry Pi3  

信息采集：Pi camera含红外技术

### 2.3）体系结构

![](image\体系结构.png)

### 2.4）尚未解决的问题

无

## **3．接口设计**

**注：**带[MANAGER]后缀的为只有管理员账户可访问

### 3.1）用户相关

#### 	3.1.1） 用户登录

​		**地址**：/user/login
​		**参数**：{
​			user	: 	用户名,
​			pw		:	密码加盐哈希
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 登录成功
​						-1 为密码错误或无用户
​			group	:	身份组
​						0 为 管理员
​						1 为 普通用户
​			token	:	验证串，用于后续操作验证用户身份
​		}
​		**描述**：
​			用户使用用户名和密码登录系统，返回token，以下的所有操作均需要使用token+uid作为用户验证。

#### 	3.1.2）	用户退出

​		**地址**：/user/logout
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 退出成功
​						-1 为身份验证错误
​		}
​		**描述**：
​			用户退出。

#### 	3.1.3）	用户密码修改

​		**地址**：/user/pwchange
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串,
​			newpw	:	新密码加盐哈希
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 修改成功
​						-1 为身份验证错误
​		}
​		**描述**：
​			修改密码，应用无状态结构理论上不需要重新登录。

#### 	3.1.4） 内网信息推送地址修改[MANAGER]

​		**地址**：/user/pschange
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串,
​			newps	:	新推送地址
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 修改成功
​						-1 为身份验证错误
​		}

#### 	3.1.5 ）添加成员[MANAGER]

​		**地址**：/user/newmember
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串,
​			newuser	:	新用户用户名,
​			newpw	:	新用户密码加盐哈希
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 添加成功
​						-1 为身份验证错误
​						1 为 其他错误（理论上不发生，应该由前端检测同名等。）
​		}

#### 	3.1.6） 删除成员[MANAGER]

​		**地址**：/user/delmember
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串,
​			duid	:	被删除uid,
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 添加成功
​						-1 为身份验证错误
​						1 为 其他错误（理论上不发生，应该由前端检测同名等。）
​		}

#### 	3.1.7） 查询成员列表[MANAGER]

​		**地址**：/user/memberlist
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串,
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 添加成功
​						-1 为身份验证错误
​						1 为 其他错误（理论上不发生，应该由前端检测同名等。）
​			list	:	[
​				{
​					uid 	:	id,
​					username:	用户名,
​					regtime	:	注册时间,
​					lastlogin:	上次登陆时间,
​				},{},{}...
​			]
​		}

#### 	3.1.8） 用户主页信息

​		**地址**：/user/info
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 添加成功
​						-1 为身份验证错误
​			uid 	:	uid
​			totalpic:	拍摄的总图片数
​		}

### 3.2）设备相关

#### 	3.2.1） 设备状态变更

​		**地址**：/drive/statechange
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串,
​			dird	:	设备id,
​			op		:	操作码
​						0 关机
​						1 暂停
​						2 重新启用
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 成功
​						-1 为身份验证错误
​						1 为 其他错误（理论上不发生，应该由前端检测。）
​		}

#### 	3.2.2） 设备列表查询

​		**地址**：/drive/drivelist
​		**参数**：{
​			user	: 	用户名,
​			token	:	验证串,
​		}
​		**返回**：{
​			state	:	状态码
​						0 为 添加成功
​						-1 为身份验证错误
​			list	:	[
​				{
​					id 		:	设备id,
​					state 	:	设备运行状态,
​					ip		:	设备ip,
​					time	:	启动时间,
​				},{},{}...
​			]
​		}

### 3.3）消息相关

#### 3.3.1）	实时消息查询[websocket]

**地址** : 规则外地址 : ws://ip:port/strust2/picmessage
		只收不发。
**当新消息接收时，返回**：{
			id		:	照片id,
			type	:	照片类型,
						0	a类
						1	b类
						2	c类
			url		:	图片地址,
			dirid	:	设备id,
			time	:	拍摄时间
		}

#### 3.3.2） 总消息查询

​	**地址**：/picmessage/query
​	**参数**：{
​		user	: 	用户名,
​		token	:	验证串,
​		starttime	:	开始日期(时间戳)
​		endtime	:	结束日期(时间戳)
​		driveid	:	设备id
​					-1：全部，其他为对应设备
​		type	:	类型id
​					-1：全部，其他为对应，参照3.1
​	}
​	**返回**：{
​		state	:	状态码
​					0 为 添加成功
​					-1 为身份验证错误
​					1 参数错误
​		list	:	[
​			{
​				id		:	照片id,
​				type	:	照片类型,
​							0	a类
​							1	b类
​							2	c类
​				url		:	图片地址,
​				dirid	:	设备id,
​				time	:	拍摄时间
​			},{},{}...
​		]
​	}



## **4．模块结构设计**

### 4.1) 模块元素列表

**树莓派端：**

a.入侵照片采集

b.入侵物品分类

c.终端部署

d.采集端-服务端 信息交互

**服务器端：**

a.捕获结果记录

b.基于长连接的实时信息交互

c.设备远程管理

**客户端：**

a.外部信息推送

b.简单的账户管理系统

c.界面UI

### 4.2) 模块元素内部关系图

![](image\模块设计.png)

### 4.3) 模块数据流程图

![](image\系统结构.png)



### 4.4) 功能实现介绍

#### 4.4.1）树莓派端：

##### a.入侵照片采集

使用OpenCV运动物体检测技术检测运动物体，之后使用高斯模糊技术、背景移除技术实现运动物体分离，使用物体标记技术进行标记并采集。

高斯模糊技术：

高斯模糊的原理是根据高斯曲线调节像素色值，它是有选择地模糊图像。就是高斯模糊能够把某一点周围的像素色值按高斯曲线统计起来，采用数学上的计算方法得到这条曲线的色值，最后能够留下人物的轮廓，即曲线，我们就可以检测到它——通常这些变化和我们视频中的运动物体有关。

```python
 #frame = imutils.resize(frame, width=500)

 dim = None

 (hh,ww) = frame.shape[:2]

 rr = 500/float(ww)

 dim = (500,int(hh * rr))

 frame = cv2.resize(frame,dim,interpolation=cv2.INTER_AREA)

 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

 gray = cv2.GaussianBlur(gray, (21, 21), 0)
```

背景模糊技术：

我们视频流中的背景在连续的视频帧内，多数时候应该是静止不变的，因此如果我们可以建立背景模型，如果背景发生了显著的变化，我们就可以检测到它——通常这些变化和我们视频中的运动物体有关。

cv2.accumulateWeighted(gray, avg, 0.5)

​    frameDelta = cv2.absdiff(gray, cv2.convertScaleAbs(avg))

​    thresh = cv2.threshold(frameDelta, conf["delta_thresh"], 255,

​                           cv2.THRESH_BINARY)[1]

​    thresh = cv2.dilate(thresh, None, iterations=2)

​    cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,

​                            cv2.CHAIN_APPROX_SIMPLE)

##### b.入侵物品分类

根据采集到的照片数据对入侵物体进行分类。

##### c.终端部署

终端启动脚本。

##### d.采集端-服务端 信息交互

采用心跳监测技术确保连接。

websocket技术保证长连接传输数据到服务器端。

#### 4.4.2）服务器端：

##### a.捕获结果记录

后台接收采集端传来的数据，构建数据库存储数据。

##### b.基于长连接的实时信息交互

websocket技术保证长连接传输数据到客户端。

##### c.设备远程管理

查看设备运行状态，将更改信息传送至采集端实现设备参数管理。

#### 4.4.3）客户端：

##### a.外部信息推送

接收到服务器端传来的数据信息并推送到网页。

##### b.简单的账户管理系统

账户分为管理员账户和普通账户；管理员账户对于普通用户有增加、删除、修改的权限，管理员和普通用户可以查看最新照片，进行个人设置，但管理员账户还可以远程更改设备设施，查看在线成员设备。

##### c.界面UI

要求界面UI设计精美，色彩的选择和搭配合适，布局合理，用户体验舒适。



## **5. UI设计**



![](image\UI设计.png)

## **6．内部错误处理机制**

### 6.1) 内部错误处理方案

方案一：遇到错误，方法立即结束，并不返回一个值；同时，抛出一个异常对象 。

方案二：调用该方法的程序不会继续执行下去，而是搜索一个可以处理该异常的异常处理器，并执行其中的代码。

### 6.2) 内部错误处理能力

程序各方法有可能出现错误的方法均采用两种错误处理方案之一，表现为命令无效或弹窗提示等之类，要求错误处理能力高。

### 6.3) 不准备处理的错误

无